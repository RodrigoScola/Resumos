acid 
     atomicity
     consistency
     isolation
     durability

acid is a set of propertis of database transactions intended to guarantee data validity despite errors, power failures and other mishaps

characteristics
     atomicity 
          transactions are often composed of multiple statements. atomicity guarantees that each transactions is treated as a single unit 
     consistency 
          a transaction can only bring the database from one valid state to another, maintaining database invariants. any data written to the database must be valid according to the definad rules. 
     isolation 
          transactions are often executed concurrently, isolation ensures that concurrent execution of transactions leaves the database in the same state that would have been obtained it the transactions were executed sequentially.
     durability
          guarantees that once a transaction has been committed, it will remain committed even in the case of a system failure 

base 
     basically available 
          the system is guaranteed to be available for querying by all users
     soft state 
          the values stored in the system may change because of the eventual consistency model
     eventually consistent 
          as data is added to the system, the systems state is gradually replicated across all nodes

index
     when working with databases they can become massive very quickly. without organization large databases can become nothing but useless information 
     an index is an organization of the data in a table to help with performance when seraching and filtering records. a table can have zero, one or as many indexes as it wants
to see what indexes are on a table 
     select * from pg_Indexes where tablename = 'table_name';
     pg_Indexes is a biult in view in postgresql
          you can get 
               schemaname , tablename , indexname , tablespace , indexdef;

what is the benefit of an index 
     it allows you to organize the database structure in such a way that it makes finding specific records much faster

to truly see the benefits of an index you will need a big database

to see how much rows it queried and the execution time, use explain analyze and the query 
     explain analyze select * from tableName;
when you use the explain analyze, it doesnt return the results in itself, just the information

biulding an index 
     the create index keywords can be used to create an index on a column of a table
     say that you wanted to create an index called customers_user_name_idx on the customers table on the user_name column 
          create index customers_user_name_idx on customers (user_name);
     but nothing comes without a cost, it increases runtime for any modification to the table data impacting the user_name column.

what if you have two or more columns that are always associated togheter? you can combine them to make a more appropriate index 
create index customers_first_and_last_name_idx on customers (first_name,last_name);
if you make the index and query it again it makes it like 10x faster

dropping an index 
     drop index if exists customers_city_idx;
     
